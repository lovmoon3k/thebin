#!/usr/bin/env python3

# This is a port of my C# Menu to Python: https://pastebin.com/9NmGvV4y

# SOURCE: https://docs.python.org/2/library/curses.html
# SOURCE: https://docs.python.org/3/howto/curses.html

# For Windows: pip install windows-curses
import curses
window = curses.initscr() # Initialize the library. Returns a WindowObject which represents the whole screen.
window.keypad(True) # Escape sequences generated by some keys (keypad, function keys) will be interpreted by curses.
curses.cbreak() # Keys are read one by one. Also safer than curses.raw() because you can still interrupt a running script with hotkeys.
curses.noecho() # Prevent getch() keys from being visible when pressed. Echoing of input characters is turned off.

# Initialize colors.
curses.start_color() # Must be called if the programmer wants to use colors.
curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
curses.init_pair(3, curses.COLOR_RED, curses.COLOR_BLACK)
curses.init_pair(4, curses.COLOR_GREEN, curses.COLOR_BLACK)
curses.init_pair(5, curses.COLOR_YELLOW, curses.COLOR_BLACK)
curses.init_pair(6, curses.COLOR_BLUE, curses.COLOR_BLACK)
curses.init_pair(7, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
curses.init_pair(8, curses.COLOR_CYAN, curses.COLOR_BLACK)
black = curses.color_pair(1)
white = curses.color_pair(2)
red = curses.color_pair(3)
green = curses.color_pair(4)
yellow = curses.color_pair(5)
blue = curses.color_pair(6)
magenta = curses.color_pair(7)
cyan = curses.color_pair(8)

def main():
    indent = ' '
    outdent = '\n\n'

    selectedIndex = 0

    while True:
        #  window.erase()
        window.clear()

        # Print a vertical menu.
        for i in range(len(MENU_OPTIONS)):
            menuOption = MENU_OPTIONS[i]
            write_menu_entry(menuOption, i == selectedIndex, indent, outdent)

        # Print a dividing line.
        window.addstr(('-' * 80) + '\n')

        # Print a horizontal menu.
        for i in range(len(MENU_OPTIONS)):
            menuOption = MENU_OPTIONS[i]
            write_menu_entry(menuOption, i == selectedIndex, indent)

        window.addstr('\n')

        # Process input.
        userInput = window.getch()

        if userInput == curses.KEY_LEFT or userInput == curses.KEY_UP:
            # Loop around backwards.
            selectedIndex = (selectedIndex - 1 + len(MENU_OPTIONS)) % len(MENU_OPTIONS)

        elif userInput == curses.KEY_RIGHT or userInput == curses.KEY_DOWN:
            # Loop around forwards.
            selectedIndex = (selectedIndex + 1) % len(MENU_OPTIONS)

        # If curses.nonl() is called, Enter key = \r else \n.
        elif userInput == curses.KEY_ENTER or chr(userInput) in '\r\n':
            execute_menu_entry(selectedIndex)

        else:
            window.addstr("\n{}The pressed key '{}' {} is not associated with a menu function.\n\n".format(indent, chr(userInput), userInput))
            wait_for_any_keypress()

def write_menu_entry(text, highlight, indent='', outdent=''):
    window.addstr(indent)
    window.addstr(text, black if highlight else white)
    window.addstr(outdent)

def execute_menu_entry(index):
    # If the last option, exit, is selected.
    if index == len(MENU_OPTIONS) - 1:
        wait_for_any_keypress()
        curses.endwin() # De-initialize the library, and return terminal to normal status.    <-- Works without this on Windows but, in Linux you can't type in the terminal after exiting without this :P

        import sys
        sys.exit(0)

    window.addstr('\n  Selected index: {}\n\n'.format(index))
    wait_for_any_keypress()

def wait_for_any_keypress():
    window.addstr('Press any key to continue . . . ')
    window.getch()

MENU_OPTIONS = [
    ' Option 1 ',
    ' Option 2 ',
    ' Option 3 ',
    ' Exit ',
]

if __name__ == '__main__':
    main()