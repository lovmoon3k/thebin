ЛР1. Метод Гаусса с выбором главного элемента. Выбор главного элемента по строкам и по столбцам. Можно сделать только для квадратных матриц.
ЛР2. Решение нелинейных уравнений. Выбор метода - самостоятельно.
ЛР3. Численное интегрирование. Порядок точности, устойчивость, сходимость и т.д.
ЛР4. Численное решение дифференциальных уравнений. Выбор метода - самостоятельно.
ЛР5 . Быстрое преобразование Фурье.

ЛР2.
Один из простых методов решения нелинейных уравнений на Python - это метод половинного деления (деления на половину). Этот метод основан на идее, что если функция f(x) имеет разные знаки в двух разных точках a и b, то должна существовать точка c между a и b, где f(c) = 0. Он ищет решение, деля область поиска на две части и выбирает ту часть, в которой знак функции меняется. Затем процедура повторяется для выбранной части, пока точность не достигнет необходимого уровня.

def bisection(func, a, b, tol=10e-5):
    c = (a + b) / 2
    while abs(func(c)) > tol:
        if func(c) == 0:
            return c
        elif func(a) * func(c) < 0:
            b = c
        else:
            a = c
        c = (a + b) / 2
    return c

Здесь функция func - это функция, удовлетворяющая условию f(x) = 0, a и b - точки, между которыми ищется решение, tol - допустимая точность. Вы можете использовать эту функцию для решения конкретных нелинейных уравнений. Для этого нужно определить функцию func, задать область поиска a и b, и вызвать функцию bisection.

Например, для решения уравнения cos(x) - x = 0 можно написать следующий код:

import math

def func(x):
    return math.cos(x) - x

a = 0
b = 2

result = bisection(func, a, b)

print("The solution is:", result)


ЛР4.
Численное решение дифференциальных уравнений может быть выполнено с помощью метода Эйлера, который представляет собой простой численный метод интегрирования.

def euler(f, x0, y0, x_max, h):
    x = x0
    y = y0
    while x < x_max:
        y = y + h * f(x, y)
        x = x + h
    return y

def f(x, y):
    return x + y

x0 = 0
y0 = 1
x_max = 2
h = 0.1

result = euler(f, x0, y0, x_max, h)

print("The solution is:", result)

Обратите внимание, что этот метод является неточным и имеет ограниченную точность. Для более точных решений рекомендуется использовать сторонние библиотеки, такие как scipy, numpy, sympy и т.д.

ЛР5.
Быстрое преобразование Фурье (FFT) может быть реализовано с использованием встроенных функций Python, таких как cmath и numpy. Вот пример реализации FFT для действительных чисел:

import cmath

def fft(x):
    N = len(x)
    if N <= 1:
        return x
    even = fft(x[0::2])
    odd = fft(x[1::2])
    T = [cmath.exp(-2j*cmath.pi*k/N)*odd[k] for k in range(N//2)]
    return [even[k] + T[k] for k in range(N//2)] + [even[k] - T[k] for k in range(N//2)]

x = [1, 2, 3, 4]
result = fft(x)

print("The FFT of", x, "is", result)

Обратите внимание, что вышеприведенный код является упрощенным и не является оптимальным. Для более эффективных и полных реализаций рекомендуется использовать сторонние библиотеки, такие как numpy или scipy.
Для вывода графиков в Python можно использовать библиотеку matplotlib. Для этого нужно добавить следующие строки кода:

import matplotlib.pyplot as plt

# ... остальной код FFT

x_axis = range(len(x))
plt.plot(x_axis, x, label="Input")

real_part = [result[i].real for i in range(len(result))]
imag_part = [result[i].imag for i in range(len(result))]

plt.plot(x_axis, real_part, label="Real Part")
plt.plot(x_axis, imag_part, label="Imaginary Part")

plt.xlabel("Sample Number")
plt.ylabel("Amplitude")
plt.title("FFT Plot")
plt.legend()
plt.show()

Этот код выведет график, показывающий входные данные, часть действительных и часть мнимых чисел в результате Быстрого преобразования Фурье.