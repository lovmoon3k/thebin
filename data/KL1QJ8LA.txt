#include "myRect.h"
#include "myString.h"
#include <iostream>
#include "string"
#include "Barrel.h"

#define stop __asm nop

int main() {
    using namespace std;

    //Задание 1.Объявление класса. Создание экземпляра класса.
    //Вызов методов класса.
    //Откройте закладку Class View - (здесь Вы увидите имена методов и
    //данных - классов Rect и MyString)
    //Обратите внимание на пиктограммы слева от имен членов класса - они
    //обозначают спецификатор доступа к каждому члену класса.

    //Какой конструктор вызывается при создании экземпляра класса?
    {
        Rect rect; // конструктор по умолчанию
    }

    //1a. Объявите и определите конструктор с параметрами для
    //инициализации переменных класса. Создайте экземляры класса Rect
    //с помощью конструктора с параметрами. Если компилятор выдает
    //ошибку в предыдущем фрагменте, подумайте - чего ему не
    //хватает? Добейтесь отсутствия ошибок.
    //Выполняя задание с самого начала по шагам, определите:
    //в какой момент происходит вызов конструктора(какого?)?

    Rect rect1(1, 1, 2, 2);
    // во время инициализации переменной (конструктор без параметров)

    //Подсказка: учтите, что пользователь Вашего класса может указывать
    //в качестве параметров любые значения!


    //1б. При конструировании объекта посредством конструктора без параметров
    //предусмотрите инициализацию переменных класса, например, нулем



    //1в. Объявите, определите и вызовите метод класса InflateRect(),
    //который увеличивает размеры прямоугольника на заданные приращения
    //(раздвигая стороны от центра - каждую сторону на свое значение).
    //Подсказка: объявить и определить методы можно не только "вручную",
    //но и с помощью Wizard-a Class View. Для этого: откройте закладку
    //ClassView окна проекта, сделайте активным класс Rect и нажмите
    //правую кнопку мыши - в появившемся контекстном меню выберите
    //Add/Add Member Function... С помощью появившейся диалоговой панели
    //"дайте указания" Wizard-у как объявить и определить метод.




    //Задание 2.Перегрузка конструкторов и методов класса.
    //Конструктор копирования.

    //2а.Объявите и определите конструктор копирования в классе Rect.
    //Выполняя задание по шагам, определите, какой
    //конструктор вызывается при создании r1,r2,r3 и r4?
    //Чему равны переменные созданных объектов?

    Rect r1; // конструктор без параметров
    Rect r2(1, 2, 3, 4); //    Rect(int mLeft, int mRight, int mTop, int mBottom);
    Rect r3 = r1; // конструктор копирования
    Rect r4(r2); // конструктор копирования



    //2б. Объявите и определите в классе Rect метод InflateRect(),
    //который принимает два аргумента, по умолчанию равных 1, и
    //раздвигает стороны прямоугольника на заданные приращения.
    //Для каких объектов вызывается функция InflateRect()?
    r1.InflateRect(1, 1);
    r2.InflateRect(2, 2);

    //Какая из функций InflateRect() вызывается в каждом из трех случаев?
    r3.InflateRect(2, 2, 2, 2);    // Rect InflateRect(int mLeft, int mRight, int mTop, int mBottom);
    r3.InflateRect(3, 3);     // Rect InflateRect(int mLeft = 1, int mTop = 1);
    r3.InflateRect(5);     // Rect InflateRect(int mLeft = 1, int mTop = 1);
    r3.InflateRect(); //    Rect InflateRect(int mLeft = 1, int mTop = 1);



    //Задание 3.Спецификаторы доступа. Инкапсуляция.
    {
        Rect r;
        //Раскомментируйте следующую строку. Объясните ошибку
        //компилятора

        //	int tmp = r.m_left;

        // Ответ: попытка обратиться к приватному полю класса


        //Введите в класс Rect метод void SetAll(...),
        //который присваивают переменным класса передаваемые
        //значения. Вызовите созданный метод, проверьте корректность.
        r.setAll(1, 1, 2, 2);

        //Введите в класс Rect парный метод GetAll(...),
        //который "достает" значения private-переменных класса.
        //Вызовите созданный метод, проверьте корректность.

        int x1, x2, y1, y2;						// создаем значения в которые будем возвращать приватные поля
        r.GetAll(&x1, &x2, &y1, &y2);
    }




    //Задание 4.Передача экземпляра класса в качестве параметра
    //функции. Возвращение объекта класса по значению. Поставив
    //остановы в конструкторе копирования или выполняя фрагмент
    //по шагам, определите: в какой момент происходит обращение
    //к конструктору копирования.
    //Создайте глобальную функцию
    // Rect BoundingRect(Rect, Rect);
    //которая принимает два объекта класса Rect по значению и
    //возвращает объект класса Rect, который является прямоугольником,
    //в который вписаны заданные прямоугольники. Как происходит
    //передача параметров и возвращение объекта класса?

    //Замечание*: хорошо было бы учесть тот факт, что прямоугольник
    //может оказаться "ненормализованным", то есть m_left>m_right или/и
    //m_top>m_bottom

    {

        Rect r1(1, 1, 3, 3), r2(5, 5, 7, 7), r3;
        // 1. Конструктор с параметрами для r2
        // 2. Конструктор с параметрами для r1
        r3 = BoundingRect(r1, r2);

        // 1. Конструктор копирования для r2
        // 2. Конструктор копирования для r1
        // 3. Функция BoundingRect()
        // 4. Внутри функции - Метод Get()
        // 5. Констурктор с параметрами
        // 6. Функция копирования
        // 7. Возврат
        // 8. деструктор

        // конструктор копирования вызывается два раза при передаче в функцию объектов r1 и r2 по значению

        //Задание 4а. Передача объектов по ссылке.
        //Создайте глобальную функцию BoundingRect2, которая выполняет ту же
        //задачу, принимая параметры по ссылке
        //Вызываются ли конструкторы при передаче параметров?


        r3 = BoundingRect2(r1, r2);
        // 1. Функция
        // 2. Метод Get()
        // 3. Констурктор с параметрами
        // 4. Конструктор копирования
        // 5. Возврат

        // Конструкторы копирования не вызываются так как объекты передаются по ссылке
    }




    //Задание 5. Когда вызываются конструкторы и деструкторы.
    //Объявите и определите
    //явный деструктор класса. Поставьте остановы в
    //конструкторе (конструкторах) и деструкторе. Определите: когда для
    //каждого из объектов вызывается конструктор, а когда - деструктор?
    {
        // конструктор r1
        Rect r1;
        // конструктор pR
        Rect *pR = new Rect(1, 2, 1, 2);
        {
            // конструктор
            Rect r2(r1);
            Rect arRect[2]; // два дефолт конструктора
            for (int i = 0; i < 3; i++) // на каждой итерации вызывается конструктор r4 и r5
            {
                static Rect r3(i, i, i, i); // 1 конструктор
                Rect r4(*pR);
                Rect r5(i, i, i, i);
            } // деструктор r4 и r5 на каждой итерации цикла
        } // деструктор r2 и два деструктора элементов массива arRect
        delete pR; // деструктор
    } // деструктор r1




    //Задание 6.Конструктор + деструктор = функциональное
    // замыкание. Класс MyString
    // Посредством конструктора (конструкторов) и деструктора обеспечьте
    //корректные инициализацию и деактивацию объекта
    //C помощью остановов определите когда происходит
    //захват и освобождение памяти для строки-члена класса
    {
        MyString str("\nIt's my string ");
        //Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
        //С помощью cout и метода GetString() распечатайте строку объекта str
        //Замечание: подумайте, как следует корректно реализовать метод GetString().
        auto x1 = str.GetString();
        cout << x1;
        // getString должен возвращать копию строки, чтобы предотвратить изменение исходной
    }// после выхода из скоупа происходит вызов деструктора и очистка памяти






    //6a. Раскомментируйте следующий фрагмент. Подумайте - какие
    //неприятности Вас ожидают. Попробуйте исправить положение (как?)
    {
        MyString str1("The first string!");
        MyString str2 = str1;
    } // повторное освобождение памяти, из за конструктора копирования по умолчанию
    // проблема решается созданием конструктора копирования, который копирует строку в новую область памяти, вместо копирования указателя

    //6б. Реализуйте метод SetNewString, который будет заменять строку
    // на новую

    {
        MyString str1("\nhi");
        cout << str1.GetString();
        str1.SetNewString("\nhello");
        cout << str1.GetString();

    }




    //Задание 7.  Решите с помощью классов следующую задачу:
    //даны две бочки известного объема. В одной бочке в начальный момент
    //времени содержится спирт (96%), в другой – вода.
    //Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
    //в другую следующим способом: на каждой итерации
    //зачерпнули из первой бочки -> вылили во вторую
    //зачерпнули из второй бочки -> вылили в первую.
    //Требуется определить номер итерации, на которой концентрация спирта в
    //первой бочке станет меньше 50%.

    //Barrel spirt(...);
    //Barrel water(...);
    //...
    //	while(концентрация спирта в бочке spirt > 50%)
    //	{
    //		spirt.Pereliv(water); //или spirt.Pereliv(water, объем_кружки);
    //		water.Pereliv(spirt); // аналогично
    //		...

    //	}
    Barrel spirt(100, 96);
    Barrel water(100, 0);

    int c = 0;
    while (spirt.getAlcPercentage() > 50) {
        spirt.Transfer(water);
        // cout << endl << "percentage " << spirt.getAlcPercentage();
        water.Transfer(spirt);
        c++;
    }
    cout << endl << "c = " << c;
    return 0;

}//end_main

